# Runner Tool Usage Examples

The `runner` tool is a diagnostic tool that helps you get fresh logs from running development servers by making HTTP calls and capturing the resulting log output.

## Basic Usage

### Get logs from a running process

```typescript
// Get diagnostic information from a process
await runner.execute({
  processId: "my-dev-server"
});
```

This will:
1. Get server information for the process
2. Capture current logs
3. Make an HTTP GET request to the root endpoint (`/`)
4. Capture new logs after the request
5. Return only the fresh logs generated by the HTTP call

## Advanced Usage

### Custom endpoint and HTTP method

```typescript
// Test a specific API endpoint
await runner.execute({
  processId: "api-server",
  endpoint: "/api/health",
  method: "POST"
});
```

### With custom timeout

```typescript
// Use a longer timeout for slow endpoints
await runner.execute({
  processId: "slow-server",
  endpoint: "/heavy-computation",
  timeout: 30000 // 30 seconds
});
```

## Common Use Cases

### 1. Debugging API Endpoints

When you need to see what logs are generated when hitting a specific endpoint:

```typescript
await runner.execute({
  processId: "backend-api",
  endpoint: "/api/users",
  method: "GET"
});
```

### 2. Testing Error Handling

See how your server handles and logs errors:

```typescript
await runner.execute({
  processId: "web-server",
  endpoint: "/invalid-route",
  method: "GET"
});
```

### 3. Health Checks

Verify your server is responding and logging correctly:

```typescript
await runner.execute({
  processId: "production-server",
  endpoint: "/health",
  method: "GET"
});
```

## Expected Output

The tool returns a formatted diagnostic report:

```
Runner Diagnostic for Process: my-dev-server
Server: Next.js Dev Server (active)
URL: http://localhost:3000
Uptime: 45 seconds

HTTP Call Result:
HTTP GET http://localhost:3000/ - Status: 200 OK
Response body: <!DOCTYPE html><html>...

Fresh Logs (3 new entries):
[2023-12-01T10:30:15.123Z] STDOUT: GET / 200 - 45ms
[2023-12-01T10:30:15.125Z] STDOUT: Compiled successfully
[2023-12-01T10:30:15.127Z] STDOUT: Request processed in 47ms
```

## Error Scenarios

### Process not found
```
Error: Process with ID 'non-existent' not found. Use the terminal tool to list running processes.
```

### Process not active
```
Error: Process 'stopped-server' is not active. Current status: stopped
```

### No server URL
```
Error: No server URL found for process 'background-task'. The process might not be a web server.
```

### HTTP request failed
```
Runner Diagnostic for Process: broken-server
Server: Express Server (active)
URL: http://localhost:3000
Uptime: 120 seconds

HTTP Call Result:
HTTP GET http://localhost:3000/ - Error: Connection refused

No new logs generated from the HTTP call.
```

## Tips

1. **Find Process IDs**: Use the `terminal` tool to list running processes and find the correct process ID
2. **Start with Root**: Begin with the root endpoint (`/`) to ensure basic connectivity
3. **Check Logs First**: Look at existing logs before using the runner tool to understand the baseline
4. **Use Appropriate Timeouts**: Adjust timeout based on your server's expected response time
5. **Test Different Methods**: Try different HTTP methods to test various endpoints

## Integration with Other Tools

The runner tool works well with other diagnostic tools:

```typescript
// First, check what processes are running
await terminal.execute({
  command: "ps aux | grep node",
  cd: "project-root"
});

// Then use runner to test the server
await runner.execute({
  processId: "found-process-id",
  endpoint: "/api/status"
});

// Finally, get more detailed logs if needed
await terminal.execute({
  command: "tail -n 50 server.log",
  cd: "project-root"
});
```
